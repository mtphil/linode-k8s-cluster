---
name: deploy_terraform_to_linode
on:
  pull_request:
  release:
    types: [released]
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  lint_and_format_pr:
    name: lint_and_format_pr
    runs-on: ubuntu-latest
    env:
      vault_endpoint: https://vault-cluster.vault.f7138e83-ed41-4970-8209-2d60a69c6a0f.aws.hashicorp.cloud:8200
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - uses: hashicorp/vault-action@v2.4.0
        with:
          url: ${{ env.vault_endpoint}}
          tlsSkipVerify: true
          method: token
          namespace: admin/yoyodynecorp
          token: ${{ secrets.VAULT_API_TOKEN }}
          secrets: |
            secret/data/github_action_linode_terraform TF_VAR_LINODE_KUBERNETES_API_TOKEN ;
            secret/data/github_action_linode_terraform CONSUL_HTTP_TOKEN
      - uses: hashicorp/setup-terraform@v2
      - name: Terraform Init
        run: terraform init -lock=false
      - name: Terraform Format
        run: terraform fmt -check
      - name: Terraform Plan
        run: terraform plan -lock=false -input=false -var-file="terraform.tfvars"

  deploy_terraform_to_linode:
    needs: lint_and_format_pr
    name: deploy_terraform_to_linode
    runs-on: ubuntu-latest
    env:
      vault_endpoint: https://vault-cluster.vault.f7138e83-ed41-4970-8209-2d60a69c6a0f.aws.hashicorp.cloud:8200
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - uses: hashicorp/vault-action@v2.4.0
        with:
          url: ${{ env.vault_endpoint}}
          tlsSkipVerify: true
          method: token
          namespace: admin/yoyodynecorp
          token: ${{ secrets.VAULT_API_TOKEN }}
          secrets: |
            secret/data/github_action_linode_terraform TF_VAR_LINODE_KUBERNETES_API_TOKEN ;
            secret/data/github_action_linode_terraform CONSUL_HTTP_TOKEN
      - uses: hashicorp/setup-terraform@v2
      - name: Terraform Init
        run: terraform init -lock=false
      - name: Terraform Format
        run: terraform fmt -check
      - name: Terraform Plan
        run: terraform plan -lock=false -input=false -var-file="terraform.tfvars"
      - name: Terraform Apply
        run: terraform apply -lock=false -auto-approve -input=false -var-file="terraform.tfvars"
      - name: Save kubeconfig to disk
        run: terraform output -json kubeconfig | jq '.value' | tr '"' > base64_kubeconfig.yaml
      - run: echo $(cat base64_kubeconfig.yaml)
      - run: echo $(cat base64_kubeconfig.yaml | base64 -d)
      - run: echo $(cat base64_kubeconfig.yaml) | base64 -d > kubeconfig.yaml  
      - name: Persist kubeconfig via actions/upload-artifact  
        uses: actions/upload-artifact@v3
        with:
          name: kubeconfig
          path: kubeconfig.yaml

  kubectl_apply:
    needs: deploy_terraform_to_linode
    name: kubectl_apply
    if: github.event_name == 'release' && github.event.action == 'released'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Get kubeconfig from cache
        uses: actions/download-artifact@v3
        with:
          name: kubeconfig
      - name: Create ArgoCD namespace
        run: kubectl create namespace argocd
      - name: Kubectl apply argo yaml
        run: kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
      - name: Use helm
        uses: azure/setup-helm@v1
      - name: Use kubectl
        uses: azure/setup-kubectl@v2.0
      - name: Add Emissary helm repo
        run: helm repo add datawire https://app.getambassador.io && helm repo update
      - name: Install Emissary CRDs
        run: kubectl create namespace emissary && kubectl apply -f https://app.getambassador.io/yaml/emissary/2.2.2/emissary-crds.yaml
      - name: Wait for CRDs to be installed
        run: kubectl wait --timeout=90s --for=condition=available deployment emissary-apiext -n emissary-system
      - name: Install Emissary
        run: helm install emissary-ingress --namespace emissary datawire/emissary-ingress && kubectl -n emissary wait --for condition=available --timeout=90s deploy -lapp.kubernetes.io/instance=emissary-ingress
      - name: Add Argo-Emissary CRD mapping
        run: kubectl apply -f k8s_yaml/emissary_crd_mapping.yaml
